# 快速排序

通过一次排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。

假设以第一个元素为基准，进行第一次循环的时候，把小于基准数的放左边，大于基准数的放右边，然后把可以把所有数据concat起来。
此后，左边和右边开始递归的进行相同方式的递归调用，最终排序完成。

时间复杂度：平均O(nlogn)，最坏O(n2)，实际上大多数情况下小于O(nlogn)

空间复杂度:O(logn)（递归调用消耗）

稳定性：不稳定

# 选择排序

每次循环将最小的数字放到前面的有序序列中

时间复杂度：O(n2)

空间复杂度:O(1)

稳定性：不稳定

# 插入排序

把左边当成一个有序队列，每次循环将一个数字插入该有序队列，插入时进行比较，较大的数字后移一位

时间复杂度：O(n2)

空间复杂度:O(1)

稳定性：稳定

# 冒泡排序

比较当前元素和下一个元素，如果当前元素比下一个元素大则向上冒泡，这样最大的元素放到最后一个
下一次循环则重复上面的操作

时间复杂度：O(n2)

空间复杂度:O(1)

稳定性：稳定
